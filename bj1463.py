testcase = int(input())

dp = [0 for _ in range(testcase + 2)]
dp[2] = 1

for i in range(2, len(dp)):

    dp[i] = dp[i - 1] + 1

    if i % 3 == 0:
        if dp[i] > dp[int(i / 3)] + 1:
            dp[i] = dp[int(i / 3)] + 1
    if i % 2 == 0:
        if dp[i] > dp[int(i / 2)] + 1:
            dp[i] = dp[int(i / 2)] + 1

print(dp[testcase])

# DP(Dynamic Programming) 동적계획법 알고리즘을 사용함
# 큰 문제를 작은 문제로 나누어 푸는 문제 말한다.
# 방법
# 모든 작은 문제들은 한번만 풀어야 한다. 따라서 정답을 구한 작은 문제를 어딘가에 메모해 놓고 그보다 큰 문제를 풀어나갈 때 똑같은 작은 문제가 나타나면 앞서 메모한 작은 문제의 결과 값을 이용한다.
# 조건
# -작은 문제가 반복이 일어나는 경우
# -같은 문제는 구할 때마다 정답이 같다.
# 위 와같은 조건을 만족하는 경우에만 동적프로그래밍을 사용할 수 있다.작은 문제의 결과 값이 항상 같다는 점을 이용해 큰 문제를 해결하는 방법이다.
# Memoization(메모이제이션)은 앞서 말한 동적프로그래밍에서 작은 문제들이 반복되고 이 작은 문제들의 결과 값이 항상 같기 때문에 이 점을 이용하여 한번 계산한 작은 문제를 저장해놓고 다시 사용하는 것을 말한다.
# Bottom-up은 작은 문제 부터 차근 차근 구해나아가는 방법이다.
# Top-down은 큰 문제를 풀 때 작은문제가 아직 풀리지 않았다면 그제서야 작은 문제를 해결하는 방법이다.

# 문제 풀이
# 조건 3가지 (1. X가 3으로 나누어 떨어지면, 3으로 나눈다. 2. X가 2로 나누어 떨어지면, 2로 나눈다. 3. 1을뺀다) 를 사용해서 1을 만들기 위한 가장 적은 연산 횟수를 찾는 문제이다.
# bottom-up을 통해서 문제를 풀었다.
# DP의 기본인 점화식을 세우면 아래와 같이 나타낼 수 있다.
# 1. X가 3으로 나누어 떨어지면, 3으로 나눈다.-> D[N] = D[N/3]+1
# 2. X가 2로 나누어 떨어지면, 2로 나눈다.-> D[N] = D[N/2]+1
# 3. 1을 뺀다.-> D[N] = D[N-1]+1
# bottom-up를 사용했기 때문에 작은 문제 부터 차근 차근 구한다.
# 숫자 1은 0번의 연산이 필요
# 숫자 2는 1번의 연산이 필요(2/2)
# 숫자 3은 1번의 연산이 필요(3/3)
# 숫자 4는 2번의 연산이 필요(4/2/2 또는 (4-1)/3)
# 숫자 5는 3번의 연산이 필요(숫자 5는 -1 조건의 연산만 가능하며 숫자 4가 되고, 숫자 4는 최소 2번의 연산이 필요)
# 숫자 6은 3번의 연산이 필요(숫자 6은 6/2=3 또는 6/3=2 이 가능하며, 결과인 숫자 2와 숫자 3 중 적은 연산이 필요했던 숫자보다 하나의 연산이 더 필요)
# 위의 과정을 반복하면 원하는 숫자의 최소 연산 횟수를 구할 수 있다.